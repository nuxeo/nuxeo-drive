# coding: utf-8
"""
We are using lazy imports (understand imports in functions) specifically here
to speed-up command line calls without loading everything at startup.
"""

import base64
import locale
import os
import sys
import time
import urlparse
from logging import getLogger

from .options import Options

DEVICE_DESCRIPTIONS = {
    'cygwin': 'Windows',
    'darwin': 'macOS',
    'linux2': 'GNU/Linux',
    'win32': 'Windows',
}
WIN32_PATCHED_MIME_TYPES = {
    'image/pjpeg': 'image/jpeg',
    'image/x-png': 'image/png',
    'image/bmp': 'image/x-ms-bmp',
    'audio/x-mpg': 'audio/mpeg',
    'video/x-mpeg2a': 'video/mpeg',
    'application/x-javascript': 'application/javascript',
    'application/x-msexcel': 'application/vnd.ms-excel',
    'application/x-mspowerpoint': 'application/vnd.ms-powerpoint',
    'application/x-mspowerpoint.12':
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
}
TOKEN_PERMISSION = 'ReadWrite'
ENCODING = locale.getpreferredencoding()

log = getLogger(__name__)


def current_milli_time():
    return int(round(time.time() * 1000))


def get_device():
    """ Retreive the device type. """

    device = DEVICE_DESCRIPTIONS.get(sys.platform)
    if not device:
        device = sys.platform.replace(' ', '')
    return device


def is_hexastring(value):
    try:
        int(value, 16)
        return True
    except ValueError:
        return False


def is_generated_tmp_file(name):
    """
    Try to guess temporary files generated by tierce softwares.
    Returns a tuple to know what kind of tmp file it is to
    filter later on Processor._synchronize_locally_created().

    :return tuple: (bool: is tmp file, bool: need to recheck later)
    """

    import re

    ignore, do_not_ignore = True, False
    delay, do_not_delay, no_delay_effect = True, False, None

    if isinstance(name, bytes):
        try:
            name = unicode(name, encoding='utf-8')
        except TypeError:
            name = name.decode(locale.getpreferredencoding() or 'utf-8')

    # Default ignored suffixes already handle .bak, .tmp, etc..
    if name.endswith(Options.ignored_suffixes):
        return ignore, do_not_delay

    # MS Office temporary file
    if len(name) == 8 and is_hexastring(name):
        # Permit to recheck later, else we have to ban all file names
        # that are only hexadecimal characters.
        return ignore, delay

    # Emacs auto save file
    # http://www.emacswiki.org/emacs/AutoSave
    if name.startswith('#') and name.endswith('#'):
        return ignore, do_not_delay

    # See https://stackoverflow.com/a/10591106/1117028 for benchmark
    reg = re.compile('|'.join('(?:%s)' % p for p in Options.ignored_files))
    if reg.match(name.lower()):
        return ignore, do_not_delay

    return do_not_ignore, no_delay_effect


def version_compare(x, y):
    """
    Compare version numbers using the usual x.y.z pattern.

    For instance, will result in:
        - 5.9.3 > 5.9.2
        - 5.9.3 > 5.8
        - 5.8 > 5.6.0
        - 5.10 > 5.1.2
        - 1.3.0524 > 1.3.0424
        - 1.4 > 1.3.0524
        - ...

    Also handles snapshots and hotfixes:
        - 5.9.4-SNAPSHOT > 5.9.3-SNAPSHOT
        - 5.9.4-SNAPSHOT > 5.9.3
        - 5.9.4-SNAPSHOT < 5.9.4
        - 5.9.4-SNAPSHOT < 5.9.5
        - 5.8.0-HF15 > 5.8
        - 5.8.0-HF15 > 5.7.1-SNAPSHOT
        - 5.8.0-HF15 < 5.9.1
        - 5.8.0-HF15 > 5.8.0-HF14
        - 5.8.0-HF15 > 5.6.0-HF35
        - 5.8.0-HF15 < 5.10.0-HF01
        - 5.8.0-HF15-SNAPSHOT > 5.8
        - 5.8.0-HF15-SNAPSHOT > 5.8.0-HF14-SNAPSHOT
        - 5.8.0-HF15-SNAPSHOT > 5.8.0-HF14
        - 5.8.0-HF15-SNAPSHOT < 5.8.0-HF15
        - 5.8.0-HF15-SNAPSHOT < 5.8.0-HF16-SNAPSHOT
    """

    # Handle None values
    if not all((x, y)):
        return cmp(x, y)

    ret = (-1, 1)

    x_numbers = x.split('.')
    y_numbers = y.split('.')
    while x_numbers and y_numbers:
        x_number = x_numbers.pop(0)
        y_number = y_numbers.pop(0)

        # Handle hotfixes
        if 'HF' in x_number:
            hf = x_number.replace('-HF', '.').split('.', 1)
            x_number = hf[0]
            x_numbers.append(hf[1])
        if 'HF' in y_number:
            hf = y_number.replace('-HF', '.').split('.', 1)
            y_number = hf[0]
            y_numbers.append(hf[1])

        # Handle snapshots
        x_snapshot = 'SNAPSHOT' in x_number
        y_snapshot = 'SNAPSHOT' in y_number
        if not x_snapshot and y_snapshot:
            # y is snapshot, x is not
            x_number = int(x_number)
            y_number = int(y_number.replace('-SNAPSHOT', ''))
            return ret[y_number <= x_number]
        elif not y_snapshot and x_snapshot:
            # x is snapshot, y is not
            x_number = int(x_number.replace('-SNAPSHOT', ''))
            y_number = int(y_number)
            return ret[x_number > y_number]

        x_number = int(x_number.replace('-SNAPSHOT', ''))
        y_number = int(y_number.replace('-SNAPSHOT', ''))
        if x_number != y_number:
            return ret[x_number - y_number > 0]

    if x_numbers:
        return 1
    if y_numbers:
        return -1

    return 0


def version_compare_client(x, y):
    """ Try to compare SemVer and fallback to version_compare on error. """

    from distutils.version import StrictVersion

    try:
        return cmp(StrictVersion(x), StrictVersion(y))
    except (AttributeError, ValueError):
        return version_compare(x, y)


def version_between(x, y, z):
    """ x <= y <= y """
    return version_le(x, y) and version_le(y, z)


def version_le(x, y):
    """ x <= y """
    return version_compare_client(x, y) <= 0


def version_lt(x, y):
    """ x < y """
    return version_compare_client(x, y) < 0


def normalized_path(path):
    """ Return absolute, normalized file path. """
    if isinstance(path, bytes):
        # Decode path with local encoding when not already decoded explicitly
        # by the caller
        path = path.decode(ENCODING)

    return os.path.realpath(
        os.path.normpath(os.path.abspath(os.path.expanduser(path))))


def normalize_event_filename(filename, action=True):
    # type: (unicode, bool) -> unicode
    """
    Normalize a file name.

    :param unicode filename: The file name to normalize.
    :param bool action: Apply changes on the file system.
    :return unicode: The normalized file name.
    """

    import unicodedata

    # NXDRIVE-688: Ensure the name is stripped for a file
    stripped = filename.strip()
    if sys.platform == 'win32':
        # Windows does not allow files/folders ending with space(s)
        filename = stripped
    elif (action
          and filename != stripped
          and os.path.exists(filename)
          and not os.path.isdir(filename)):
        # We can have folders ending with spaces
        log.debug('Forcing space normalization: %r -> %r', filename, stripped)
        os.rename(filename, stripped)
        filename = stripped

    # NXDRIVE-188: Normalize name on the file system, if needed
    try:
        normalized = unicodedata.normalize('NFC', unicode(filename, 'utf-8'))
    except TypeError:
        normalized = unicodedata.normalize('NFC', unicode(filename))

    if sys.platform == 'darwin':
        return normalized
    elif sys.platform == 'win32' and os.path.exists(filename):
        """
        If `filename` exists, and as Windows is case insensitive,
        the result of Get(Full|Long|Short)PathName() could be unexpected
        because it will return the path of the existant `filename`.

        Check this simplified code session (the file "ABC.txt" exists):

            >>> win32api.GetLongPathName('abc.txt')
            'ABC.txt'
            >>> win32api.GetLongPathName('ABC.TXT')
            'ABC.txt'
            >>> win32api.GetLongPathName('ABC.txt')
            'ABC.txt'

        So, to counter that behavior, we save the actual file name
        and restore it in the full path.
        """
        import win32api
        long_path = win32api.GetLongPathNameW(filename)
        filename = os.path.join(os.path.dirname(long_path),
                                os.path.basename(filename))

    if action and filename != normalized and os.path.exists(filename):
        log.debug('Forcing normalization: %r -> %r', filename, normalized)
        os.rename(filename, normalized)

    return normalized


def safe_long_path(path):
    """
    Utility to prefix path with the long path marker for Windows
    Source: http://msdn.microsoft.com/en-us/library/aa365247.aspx#maxpath

    We also need to normalize the path as described here:
        https://bugs.python.org/issue18199#msg260122
    """
    if sys.platform == 'win32':
        if isinstance(path, bytes):
            # Decode path with local encoding when not already decoded
            # explicitly by the caller
            path = unicode(path.decode(ENCODING))

        if not path.startswith(u'\\\\?\\'):
            path = u'\\\\?\\' + normalized_path(path)

    return path


def path_join(parent, child):
    if parent == '/':
        return '/' + child
    return parent + '/' + child


def find_icon(icon):
    return find_resource('icons', icon)


def find_resource(folder, filename=''):
    """ Find the FS path of a directory in various OS binary packages. """

    path = os.path.join(Options.res_dir, folder, filename)
    if not os.path.exists(path):
        log.error('Could not find the resource %r', path)
        path = None
    return path


def force_decode(string, codecs=('utf-8', 'cp1252')):
    if isinstance(string, unicode):
        string = string.encode('utf-8')
    for codec in codecs:
        try:
            return string.decode(codec)
        except UnicodeDecodeError:
            pass
    log.debug("Cannot decode string '%s' with any of the given codecs: %r",
              string, codecs)


def encrypt(plaintext, secret, lazy=True):
    """ Symetric encryption using AES. """

    from Cryptodome.Random import get_random_bytes
    from Cryptodome.Cipher import AES

    secret = _lazysecret(secret) if lazy else secret
    iv = get_random_bytes(AES.block_size)
    encobj = AES.new(secret, AES.MODE_CFB, iv)
    return base64.b64encode(iv + encobj.encrypt(plaintext))


def decrypt(ciphertext, secret, lazy=True):
    """ Symetric decryption using AES. """

    from Cryptodome.Cipher import AES

    secret = _lazysecret(secret) if lazy else secret
    ciphertext = base64.b64decode(ciphertext)
    iv = ciphertext[:AES.block_size]
    ciphertext = ciphertext[AES.block_size:]

    # Don't fail on decrypt
    try:
        encobj = AES.new(secret, AES.MODE_CFB, iv)
        return encobj.decrypt(ciphertext)
    except:
        return None


def _lazysecret(secret, blocksize=32, padding='}'):
    """Pad secret if not legal AES block size (16, 24, 32)"""
    if len(secret) > blocksize:
        return secret[:-(len(secret) - blocksize)]
    if not len(secret) in (16, 24, 32):
        return secret + (blocksize - len(secret)) * padding
    return secret


def guess_mime_type(filename):
    import mimetypes

    mime_type, _ = mimetypes.guess_type(filename)
    if mime_type:
        if sys.platform == 'win32':
            # Patch bad Windows MIME types
            # See https://jira.nuxeo.com/browse/NXP-11660
            # and http://bugs.python.org/issue15207
            mime_type = WIN32_PATCHED_MIME_TYPES.get(mime_type, mime_type)
        log.trace('Guessed mime type %r for %r', mime_type, filename)
        return mime_type
    log.trace("Could not guess mime type for '%s', returing 'application/octet-stream'", filename)
    return "application/octet-stream"


def guess_digest_algorithm(digest):
    # For now only md5 and sha1 are supported
    if digest is None or len(digest) == 32:
        return 'md5'
    elif len(digest) == 40:
        return 'sha1'
    raise Exception('Unknown digest algorithm for %s' % digest)


def guess_server_url(url, login_page=Options.startup_page, timeout=5):
    """
    Guess the complete server URL given an URL (either an IP address,
    a simple domain name or an already complete URL).

    :param url: The server URL (IP, domain name, full URL).
    :param login_page: The Drive login page.
    :param int timeout: Timeout for each and every request.
    :return: The complete URL.
    """

    from urllib2 import HTTPError, URLError, urlopen
    import rfc3987

    parts = urlparse.urlsplit(str(url))

    # IP address or domain name only
    if parts.scheme:
        """
        Handle that kind of `url`:

        >>> urlparse.urlsplit('192.168.0.42:8080/nuxeo')
        SplitResult(scheme='192.168.0.42', netloc='', path='8080/nuxeo', ...)
        """
        domain = ':'.join([parts.scheme, parts.path.strip('/')])
    else:
        domain = parts.path.strip('/')

    # URLs to test
    urls = [
        # First, test the given URL
        parts,
        # URL/nuxeo
        (parts.scheme, parts.netloc, parts.path + '/nuxeo',
         parts.query, parts.fragment),
        # URL:8080/nuxeo
        (parts.scheme, parts.netloc + ':8080', parts.path + '/nuxeo',
         parts.query, parts.fragment),

        # https://domain.com/nuxeo
        ('https', domain, 'nuxeo', '', ''),
        ('https', domain + ':8080', 'nuxeo', '', ''),
        # https://domain.com
        ('https', domain, '', '', ''),
        # https://domain.com:8080/nuxeo

        # http://domain.com/nuxeo
        ('http', domain, 'nuxeo', '', ''),
        # http://domain.com:8080/nuxeo
        ('http', domain + ':8080', 'nuxeo', '', ''),
        # http://domain.com
        ('http', domain, '', '', ''),
    ]

    for new_url_parts in urls:
        new_url = urlparse.urlunsplit(new_url_parts)
        try:
            rfc3987.parse(new_url, rule='URI')
            log.trace('Testing URL %r', new_url)
            ret = urlopen(new_url + '/' + login_page, timeout=timeout)
        except HTTPError as exc:
            if exc.code == 401:
                # When there is only Web-UI installed, the code is 401.
                return new_url
        except (ValueError, URLError):
            pass
        else:
            if ret.code == 200:
                return new_url

    if not url.lower().startswith('http'):
        return None
    return url


def simplify_url(url):
    # type: (Text) -> Text
    """ Simplify port if possible and trim trailing slashes. """

    parts = urlparse.urlsplit(url)
    new_parts = [parts.scheme,
                 parts.netloc,
                 parts.path,
                 parts.query,
                 parts.fragment]

    if parts.scheme == 'http' and parts.netloc.endswith(':80'):
        new_parts[1] = parts.netloc[:-3]
    elif parts.scheme == 'https' and parts.netloc.endswith(':443'):
        new_parts[1] = parts.netloc[:-4]

    return urlparse.urlunsplit(new_parts).rstrip('/')


class PidLockFile(object):
    """ This class handle the pid lock file"""
    def __init__(self, folder, key):
        self.folder = folder
        self.key = key
        self.locked = False

    def _get_sync_pid_filepath(self, process_name=None):
        if process_name is None:
            process_name = self.key
        return os.path.join(self.folder, 'nxdrive_%s.pid' % process_name)

    def unlock(self):
        if not self.locked:
            return
        # Clean pid file
        pid_filepath = self._get_sync_pid_filepath()
        try:
            os.unlink(pid_filepath)
        except Exception, e:
            log.warning('Failed to remove stalled PID file: %r'
                        ' for stopped process %d: %r',
                        pid_filepath, os.getpid(), e)

    def check_running(self, process_name=None):
        """Check whether another sync process is already runnning

        If nxdrive.pid file already exists and the pid points to a running
        nxdrive program then return the pid. Return None otherwise.

        """

        import psutil

        if process_name is None:
            process_name = self.key
        pid_filepath = self._get_sync_pid_filepath(process_name=process_name)
        if os.path.exists(pid_filepath):
            with open(safe_long_path(pid_filepath), 'rb') as f:
                pid = os.getpid()
                try:
                    pid = int(f.read().strip())
                    p = psutil.Process(pid)
                    # If process has been created after the lock file
                    # Changed from getctime() to getmtime() because of Windows
                    # file system tunneling
                    if p.create_time() > os.path.getmtime(pid_filepath):
                        raise ValueError
                    return pid
                except (ValueError, psutil.NoSuchProcess):
                    pass
            # This is a pid file that is empty or pointing to either a
            # stopped process or a non-nxdrive process: let's delete it if
            # possible
            try:
                os.unlink(pid_filepath)
                if pid is None:
                    msg = 'Removed old empty PID file %r' % pid_filepath
                else:
                    msg = 'Removed old PID file %r for stopped process %d' % (
                        pid_filepath, pid)
                log.info(msg)
            except Exception, e:
                if pid is not None:
                    msg = ('Failed to remove stalled PID file: %r for'
                           ' stopped process %d: %r'
                           % (pid_filepath, pid, e))
                    log.warning(msg)
                    return pid
                msg = 'Failed to remove empty stalled PID file %r: %r' % (
                    pid_filepath, e)
                log.warning(msg)
        self.locked = True

    def lock(self):
        pid = self.check_running(process_name=self.key)
        if pid is not None:
            log.warning('%s process with PID %d already running', self.key, pid)
            return pid

        # Write the pid of this process
        pid_filepath = self._get_sync_pid_filepath(process_name=self.key)
        pid = os.getpid()
        with open(safe_long_path(pid_filepath), 'wb') as f:
            f.write(str(pid))
